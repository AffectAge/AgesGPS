/**
 * –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥ JSON —Å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º –æ—à–∏–±–æ–∫
 */
function safeParseJSON(str, context, rowIndex, messages) {
  try {
    return JSON.parse(str);
  } catch (e) {
    messages.push(`[–û—à–∏–±–∫–∞] üö´ –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å JSON (${context}, —Å—Ç—Ä–æ–∫–∞ ${rowIndex + 1}): ${e.message}`);
    return null;
  }
}

/**
 * –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –∏–º–µ–Ω–æ–≤–∞–Ω–Ω–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ "–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ"
 */
function extractVariableData(data, identifier, messages) {
  const targetRow = data['–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ']?.find(row => row[0] === identifier);
  if (!targetRow?.[1]) {
    messages.push(`[–û—à–∏–±–∫–∞] üîç –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä "${identifier}" –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ.`);
    return null;
  }

  const jsonMatch = targetRow[1].match(/\{.*\}/);
  if (!jsonMatch) {
    messages.push(`[–û—à–∏–±–∫–∞] üìù –ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å JSON –∏–∑ —Å—Ç—Ä–æ–∫–∏ "${identifier}" –≤ –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ.`);
    return null;
  }

  return safeParseJSON(jsonMatch[0], `–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ:${identifier}`, 0, messages);
}

/**
 * –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—á–µ—Ä–µ–¥–∏ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞
 */
function processConstructionQueue(data, buildings) {
  const messages = [];

  try {
    // –ü–æ–ª—É—á–µ–Ω–∏–µ –±–∞–∑–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    const stateData = extractVariableData(data, '–û—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≥–æ—Å—É–¥–∞—Ä—Å—Ç–≤–∞', messages);
    if (!stateData) return messages;

    const stateName = stateData.state_id;
    if (!stateName) {
      messages.push(`[–û—à–∏–±–∫–∞] üèõÔ∏è –ö–ª—é—á "state_id" –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –æ—Å–Ω–æ–≤–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –≥–æ—Å—É–¥–∞—Ä—Å—Ç–≤–∞.`);
      return messages;
    }

    const queueData = extractVariableData(data, '–û—á–µ—Ä–µ–¥—å —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞', messages);
    if (!queueData?.construction_queue || !Array.isArray(queueData.construction_queue)) {
      messages.push(`[–û—à–∏–±–∫–∞] üèóÔ∏è –û—á–µ—Ä–µ–¥—å —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –º–∞—Å—Å–∏–≤–æ–º.`);
      return messages;
    }

    const constructionQueue = queueData.construction_queue;
    messages.push(`[–°—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ] üìã –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—á–µ—Ä–µ–¥–∏: ${constructionQueue.length} —ç–ª–µ–º–µ–Ω—Ç–æ–≤.`);

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–æ–≤–∏–Ω—Ü–∏–π
    const provincesMap = {};
    let validProvinces = 0;
    
    (data['–ü—Ä–æ–≤–∏–Ω—Ü–∏–∏'] || []).forEach((row, index) => {
      if (!row[0]) return;
      
      const provinceData = safeParseJSON(row[0], '–ü—Ä–æ–≤–∏–Ω—Ü–∏–∏', index, messages);
      if (!provinceData || typeof provinceData !== 'object') return;

      if (provinceData.id) {
        provincesMap[provinceData.id] = provinceData;
        validProvinces++;
      } else {
        // –§–æ—Ä–º–∞—Ç {"province_001": {...}}
        Object.entries(provinceData).forEach(([key, value]) => {
          if (value?.id) {
            provincesMap[value.id] = value;
            validProvinces++;
          }
        });
      }
    });

    messages.push(`[–°—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ] üó∫Ô∏è –ó–∞–≥—Ä—É–∂–µ–Ω–æ ${validProvinces} –ø—Ä–æ–≤–∏–Ω—Ü–∏–π.`);

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –∑–¥–∞–Ω–∏–π
    const existingBuildings = {};
    let totalBuildings = 0;

    (data['–ü–æ—Å—Ç—Ä–æ–π–∫–∏'] || []).forEach((row, index) => {
      if (!row[0]) return;
      
      const buildingData = safeParseJSON(row[0], '–ü–æ—Å—Ç—Ä–æ–π–∫–∏', index, messages);
      if (!buildingData) return;

      const buildingsArray = Array.isArray(buildingData) ? buildingData : [buildingData];
      buildingsArray.forEach(building => {
        if (!building.province_id || !building.building_id) return;
        
        existingBuildings[building.province_id] = existingBuildings[building.province_id] || {};
        existingBuildings[building.province_id][building.building_id] = 
          (existingBuildings[building.province_id][building.building_id] || 0) + 1;
        totalBuildings++;
      });
    });

    messages.push(`[GNN] üè¢ –£—á—Ç–µ–Ω–æ ${totalBuildings} —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –∑–¥–∞–Ω–∏–π.`);

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—á–µ—Ä–µ–¥–∏
    const updatedQueue = [];
    let processedCount = 0, promotedCount = 0, removedCount = 0;
    
    constructionQueue.forEach((queueItem, index) => {
      if (queueItem.status !== '–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞' && queueItem.status !== '–°—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ') {
        updatedQueue.push(queueItem);
        return;
      }

      processedCount++;
      const buildingCriteria = buildings.find(b => b.id === queueItem.building_id);
      
      if (!buildingCriteria) {
        messages.push(`[–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ] ‚ö†Ô∏è –ó–¥–∞–Ω–∏–µ "${queueItem.building_id}" –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤ –∫—Ä–∏—Ç–µ—Ä–∏—è—Ö. –£–¥–∞–ª–µ–Ω–æ –∏–∑ –æ—á–µ—Ä–µ–¥–∏.`);
        removedCount++;
        return;
      }

      const province = provincesMap[queueItem.province_id];
      if (!province) {
        messages.push(`<cellbg:#FFEEEE> [–û—à–∏–±–∫–∞] <color:#CC0000> üó∫Ô∏è –ü—Ä–æ–≤–∏–Ω—Ü–∏—è "${queueItem.province_id}" –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ </color> –¥–ª—è –∑–¥–∞–Ω–∏—è <i>"${buildingCriteria.name}"</i>. <color:#009900> –£–¥–∞–ª–µ–Ω–æ –∏–∑ –æ—á–µ—Ä–µ–¥–∏.</color>`);
        removedCount++;
        return;
      }

      if (province.state_id !== stateName) {
        messages.push(`[–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ] üèõÔ∏è –ü—Ä–æ–≤–∏–Ω—Ü–∏—è "${province.name}" –Ω–µ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –≥–æ—Å—É–¥–∞—Ä—Å—Ç–≤—É "${stateName}". –£–¥–∞–ª–µ–Ω–æ –∏–∑ –æ—á–µ—Ä–µ–¥–∏.`);
        removedCount++;
        return;
      }

      const requirementResult = evaluateBuildingRequirements(
        buildingCriteria.requirements, province, provincesMap, 
        existingBuildings, stateName, messages, buildingCriteria.name, 
        queueItem.queue_position || index + 1
      );

      if (requirementResult.meets) {
        if (queueItem.status === '–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞') {
          queueItem.status = '–°—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ';
          messages.push(`[–°—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ] üèóÔ∏è "${buildingCriteria.name}" –≤ "${province.name}" –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–æ –≤ —Å—Ç–∞—Ç—É—Å "–°—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ".`);
          promotedCount++;
        }
        updatedQueue.push(queueItem);
      } else {
        messages.push(`[–°—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ] ‚ùå "${buildingCriteria.name}" –≤ "${province.name}" –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º –∏ —É–¥–∞–ª–µ–Ω–æ. –ü—Ä–∏—á–∏–Ω–∞: ${requirementResult.reason}`);
        removedCount++;
      }
    });

    messages.push(`[–°—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ] üìä –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ ${processedCount}, –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–æ –≤ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ ${promotedCount}, —É–¥–∞–ª–µ–Ω–æ ${removedCount}.`);

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
    const updatedQueueData = { construction_queue: updatedQueue };
    
    if (!Array.isArray(data['–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ'])) {
      data['–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ'] = [];
      messages.push(`[–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ] ‚ö†Ô∏è "–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ" –Ω–µ –Ω–∞–π–¥–µ–Ω ‚Äî —Å–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π –º–∞—Å—Å–∏–≤.`);
    }

    const queueRowIndex = data['–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ'].findIndex(row => row[0] === '–û—á–µ—Ä–µ–¥—å —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞');
    
    if (queueRowIndex !== -1) {
      data['–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ'][queueRowIndex][1] = JSON.stringify(updatedQueueData);
      messages.push(`[–°—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ] üíæ –û—á–µ—Ä–µ–¥—å –æ–±–Ω–æ–≤–ª–µ–Ω–∞: ${updatedQueue.length} —ç–ª–µ–º–µ–Ω—Ç–æ–≤.`);
    } else {
      data['–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ'].push(['–û—á–µ—Ä–µ–¥—å —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞', JSON.stringify(updatedQueueData)]);
      messages.push(`[–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ] ‚ÑπÔ∏è –î–æ–±–∞–≤–ª–µ–Ω–∞ –Ω–æ–≤–∞—è —Å—Ç—Ä–æ–∫–∞ "–û—á–µ—Ä–µ–¥—å —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞" –≤ "–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ".`);
    }

  } catch (error) {
    messages.push(`[–û—à–∏–±–∫–∞] üö® processConstructionQueue: ${error.message}`);
  }

  return messages;
}

/**
 * –û—Ü–µ–Ω–∫–∞ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π –∑–¥–∞–Ω–∏—è
 */
function evaluateBuildingRequirements(requirements, province, provincesMap, existingBuildings, stateName, messages, buildingName, queuePosition) {
  if (!requirements || typeof requirements !== 'object') {
    return { meets: true, reason: '–ù–µ—Ç —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π' };
  }

  const { logic = 'AND', conditions = [] } = requirements;
  if (!conditions.length) return { meets: true, reason: '–ü—É—Å—Ç—ã–µ —É—Å–ª–æ–≤–∏—è' };

  const results = conditions.map((condition, index) => 
    evaluateCondition(condition, province, provincesMap, existingBuildings, stateName, messages, buildingName, queuePosition, index)
  );

  const logicMap = {
    'AND': () => results.every(r => r.meets),
    'OR': () => results.some(r => r.meets),
    'NOT': () => !results.some(r => r.meets),
    'XOR': () => results.filter(r => r.meets).length === 1,
    'NAND': () => !results.every(r => r.meets),
    'NOR': () => !results.some(r => r.meets)
  };

  const meets = logicMap[logic] ? logicMap[logic]() : false;
  let reason = '';

  if (!meets) {
    const failedReasons = results.filter(r => !r.meets).map(r => r.reason);
    reason = logic === 'OR' ? 
      `–ù–∏ –æ–¥–Ω–æ —É—Å–ª–æ–≤–∏–µ –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ (OR): ${results.map(r => r.reason).join(', ')}` :
      `–ù–µ –≤—ã–ø–æ–ª–Ω–µ–Ω—ã —É—Å–ª–æ–≤–∏—è (${logic}): ${failedReasons.join(', ')}`;
  }

  return { meets, reason };
}

/**
 * –û—Ü–µ–Ω–∫–∞ –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ —É—Å–ª–æ–≤–∏—è
 */
function evaluateCondition(condition, province, provincesMap, existingBuildings, stateName, messages, buildingName, queuePosition, conditionIndex) {
  if (!condition.target) {
    return { meets: false, reason: `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç target` };
  }

  const [targetType, ...targetPath] = condition.target.split('.');
  
  try {
    const evaluators = {
      'province': () => evaluateProvinceCondition(condition, province, existingBuildings, conditionIndex),
      'state': () => evaluateStateCondition(condition, provincesMap, existingBuildings, stateName, conditionIndex),
      'planet': () => evaluatePlanetCondition(condition, province, conditionIndex),
      'world': () => evaluateWorldCondition(condition, provincesMap, existingBuildings, conditionIndex)
    };

    return evaluators[targetType] ? evaluators[targetType]() : 
      { meets: false, reason: `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π target "${targetType}"` };
  } catch (error) {
    return { meets: false, reason: `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: –æ—à–∏–±–∫–∞ –æ—Ü–µ–Ω–∫–∏ - ${error.message}` };
  }
}

/**
 * –û—Ü–µ–Ω–∫–∞ —É—Å–ª–æ–≤–∏–π –ø—Ä–æ–≤–∏–Ω—Ü–∏–∏
 */
function evaluateProvinceCondition(condition, province, existingBuildings, conditionIndex) {
  const [, property] = condition.target.split('.');

  if (property === 'buildings') {
    return evaluateBuildingsCondition(condition, province.id, existingBuildings, conditionIndex);
  }
  
  if (property === 'resources') {
    return evaluateResourcesCondition(condition, province.resources || {}, conditionIndex);
  }

  const value = province[property];
  if (value === undefined) {
    return { meets: false, reason: `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: —Å–≤–æ–π—Å—Ç–≤–æ "${property}" –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤ –ø—Ä–æ–≤–∏–Ω—Ü–∏–∏` };
  }
  
  return evaluateSimpleCondition(condition, value, conditionIndex, `province.${property}`);
}

/**
 * –û—Ü–µ–Ω–∫–∞ —É—Å–ª–æ–≤–∏–π –∑–¥–∞–Ω–∏–π –≤ –ø—Ä–æ–≤–∏–Ω—Ü–∏–∏
 */
function evaluateBuildingsCondition(condition, provinceId, existingBuildings, conditionIndex) {
  const { logic = 'AND', conditions = [] } = condition;
  if (!conditions.length) return { meets: true, reason: `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: –Ω–µ—Ç –ø–æ–¥—É—Å–ª–æ–≤–∏–π –¥–ª—è –∑–¥–∞–Ω–∏–π` };

  const results = conditions.map((subCondition, subIndex) => {
    const count = existingBuildings[provinceId]?.[subCondition.buildingId] || 0;
    return {
      ...evaluateSimpleCondition(subCondition, count, subIndex, `building.${subCondition.buildingId}`),
      buildingId: subCondition.buildingId,
      count,
      expectedValue: subCondition.value,
      operator: subCondition.operator
    };
  });

  const meets = logic === 'AND' ? results.every(r => r.meets) : results.some(r => r.meets);
  const reason = meets ? 
    `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: –∑–¥–∞–Ω–∏—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç (${logic})` :
    `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: –∑–¥–∞–Ω–∏—è –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç (${logic}): ${results.filter(r => !r.meets).map(r => 
      `${r.buildingId} (${r.count} ${r.operator} ${r.expectedValue})`).join(', ')}`;

  return { meets, reason };
}

/**
 * –û—Ü–µ–Ω–∫–∞ —É—Å–ª–æ–≤–∏–π —Ä–µ—Å—É—Ä—Å–æ–≤
 */
function evaluateResourcesCondition(condition, resources, conditionIndex) {
  const { logic = 'AND', conditions = [] } = condition;
  if (!conditions.length) return { meets: true, reason: `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: –Ω–µ—Ç –ø–æ–¥—É—Å–ª–æ–≤–∏–π –¥–ª—è —Ä–µ—Å—É—Ä—Å–æ–≤` };

  const results = conditions.map((subCondition, subIndex) => {
    const amount = resources[subCondition.resourceId] || 0;
    return {
      ...evaluateSimpleCondition(subCondition, amount, subIndex, `resource.${subCondition.resourceId}`),
      resourceId: subCondition.resourceId,
      amount,
      expectedValue: subCondition.value,
      operator: subCondition.operator
    };
  });

  const meets = logic === 'AND' ? results.every(r => r.meets) : results.some(r => r.meets);
  const reason = meets ?
    `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: —Ä–µ—Å—É—Ä—Å—ã —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç (${logic})` :
    `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: —Ä–µ—Å—É—Ä—Å—ã –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã (${logic}): ${results.filter(r => !r.meets).map(r => 
      `${r.resourceId} (${r.amount} ${r.operator} ${r.expectedValue})`).join(', ')}`;

  return { meets, reason };
}

/**
 * –û—Ü–µ–Ω–∫–∞ —É—Å–ª–æ–≤–∏–π –≥–æ—Å—É–¥–∞—Ä—Å—Ç–≤–∞
 */
function evaluateStateCondition(condition, provincesMap, existingBuildings, stateName, conditionIndex) {
  const [, property] = condition.target.split('.');

  if (property === 'buildings') {
    const stateBuildingCounts = {};
    let stateProvinceCount = 0;
    
    Object.values(provincesMap).forEach(province => {
      if (province.state_id === stateName) {
        stateProvinceCount++;
        const provinceBuildings = existingBuildings[province.id] || {};
        Object.entries(provinceBuildings).forEach(([buildingId, count]) => {
          stateBuildingCounts[buildingId] = (stateBuildingCounts[buildingId] || 0) + count;
        });
      }
    });

    const results = (condition.conditions || []).map((subCondition, subIndex) => {
      const count = stateBuildingCounts[subCondition.buildingId] || 0;
      return {
        ...evaluateSimpleCondition(subCondition, count, subIndex, `state.building.${subCondition.buildingId}`),
        buildingId: subCondition.buildingId,
        count,
        expectedValue: subCondition.value,
        operator: subCondition.operator
      };
    });

    const meets = results.every(r => r.meets);
    const reason = meets ?
      `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: –≤—Å–µ –∑–¥–∞–Ω–∏—è –≤ –≥–æ—Å—É–¥–∞—Ä—Å—Ç–≤–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º` :
      `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: –∑–¥–∞–Ω–∏—è –≤ –≥–æ—Å—É–¥–∞—Ä—Å—Ç–≤–µ –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç: ${results.filter(r => !r.meets).map(r => 
        `${r.buildingId} (${r.count} ${r.operator} ${r.expectedValue})`).join(', ')} (–ø—Ä–æ–≤–∏–Ω—Ü–∏–π: ${stateProvinceCount})`;

    return { meets, reason };
  }

  return { meets: false, reason: `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: –Ω–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–æ–µ —Å–≤–æ–π—Å—Ç–≤–æ state.${property}` };
}

/**
 * –û—Ü–µ–Ω–∫–∞ —É—Å–ª–æ–≤–∏–π –ø–ª–∞–Ω–µ—Ç—ã
 */
function evaluatePlanetCondition(condition, province, conditionIndex) {
  const [, property] = condition.target.split('.');

  if (property === 'name') {
    const result = evaluateSimpleCondition(condition, province.planet, conditionIndex, 'planet.name');
    return {
      ...result,
      reason: `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: –ø–ª–∞–Ω–µ—Ç–∞ "${province.planet}" ${result.meets ? '—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç' : '–Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç'} —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º`
    };
  }

  return { meets: false, reason: `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: –Ω–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–æ–µ —Å–≤–æ–π—Å—Ç–≤–æ planet.${property}` };
}

/**
 * –û—Ü–µ–Ω–∫–∞ —É—Å–ª–æ–≤–∏–π –º–∏—Ä–∞
 */
function evaluateWorldCondition(condition, provincesMap, existingBuildings, conditionIndex) {
  const [, property] = condition.target.split('.');

  if (property === 'buildings') {
    const worldBuildingCounts = {};
    
    Object.values(provincesMap).forEach(province => {
      const provinceBuildings = existingBuildings[province.id] || {};
      Object.entries(provinceBuildings).forEach(([buildingId, count]) => {
        worldBuildingCounts[buildingId] = (worldBuildingCounts[buildingId] || 0) + count;
      });
    });

    const results = (condition.conditions || []).map((subCondition, subIndex) => {
      const count = worldBuildingCounts[subCondition.buildingId] || 0;
      return {
        ...evaluateSimpleCondition(subCondition, count, subIndex, `world.building.${subCondition.buildingId}`),
        buildingId: subCondition.buildingId,
        count,
        expectedValue: subCondition.value,
        operator: subCondition.operator
      };
    });

    const meets = results.every(r => r.meets);
    const reason = meets ?
      `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: –≤—Å–µ –∑–¥–∞–Ω–∏—è –≤ –º–∏—Ä–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º` :
      `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: –∑–¥–∞–Ω–∏—è –≤ –º–∏—Ä–µ –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç: ${results.filter(r => !r.meets).map(r => 
        `${r.buildingId} (${r.count} ${r.operator} ${r.expectedValue})`).join(', ')}`;

    return { meets, reason };
  }

  return { meets: false, reason: `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: –Ω–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–æ–µ —Å–≤–æ–π—Å—Ç–≤–æ world.${property}` };
}

/**
 * –û—Ü–µ–Ω–∫–∞ –ø—Ä–æ—Å—Ç—ã—Ö —É—Å–ª–æ–≤–∏–π —Å –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞–º–∏
 */
function evaluateSimpleCondition(condition, actualValue, conditionIndex, target) {
  const { operator, value: expectedValue } = condition;

  if (actualValue === undefined || actualValue === null) {
    return { meets: false, reason: `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: –∑–Ω–∞—á–µ–Ω–∏–µ "${target}" –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ` };
  }

  const operators = {
    '>=': () => actualValue >= expectedValue,
    '<=': () => actualValue <= expectedValue,
    '>': () => actualValue > expectedValue,
    '<': () => actualValue < expectedValue,
    '==': () => actualValue === expectedValue,
    'equals': () => actualValue === expectedValue,
    '!=': () => actualValue !== expectedValue,
    'not_equals': () => actualValue !== expectedValue,
    'in': () => Array.isArray(expectedValue) && expectedValue.includes(actualValue),
    'contains': () => Array.isArray(expectedValue) && expectedValue.includes(actualValue),
    'not_in': () => Array.isArray(expectedValue) && !expectedValue.includes(actualValue),
    'not_contains': () => Array.isArray(expectedValue) && !expectedValue.includes(actualValue),
    'starts_with': () => typeof actualValue === 'string' && typeof expectedValue === 'string' && actualValue.startsWith(expectedValue),
    'ends_with': () => typeof actualValue === 'string' && typeof expectedValue === 'string' && actualValue.endsWith(expectedValue),
    'regex': () => {
      try {
        return new RegExp(expectedValue).test(String(actualValue));
      } catch (e) {
        throw new Error(`–æ—à–∏–±–∫–∞ –≤ regex "${expectedValue}": ${e.message}`);
      }
    },
    'matches': () => operators.regex(),
    'between': () => Array.isArray(expectedValue) && expectedValue.length === 2 && actualValue >= expectedValue[0] && actualValue <= expectedValue[1],
    'divisible_by': () => typeof actualValue === 'number' && typeof expectedValue === 'number' && expectedValue !== 0 && actualValue % expectedValue === 0,
    'is_empty': () => {
      const isEmpty = actualValue === '' || actualValue === null || actualValue === undefined || 
                     (Array.isArray(actualValue) && actualValue.length === 0) ||
                     (typeof actualValue === 'object' && Object.keys(actualValue).length === 0);
      return expectedValue ? isEmpty : !isEmpty;
    },
    'length': () => {
      const length = Array.isArray(actualValue) ? actualValue.length : 
                    typeof actualValue === 'string' ? actualValue.length : 0;
      return evaluateSimpleCondition(
        { operator: expectedValue.operator, value: expectedValue.value }, 
        length, conditionIndex, `${target}.length`
      ).meets;
    }
  };

  try {
    const meets = operators[operator] ? operators[operator]() : false;
    
    if (!operators[operator]) {
      return { meets: false, reason: `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –æ–ø–µ—Ä–∞—Ç–æ—Ä "${operator}"` };
    }

    const reason = `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: ${target} (${actualValue}) ${operator} ${Array.isArray(expectedValue) ? `[${expectedValue.join(', ')}]` : expectedValue} ${meets ? '‚úÖ' : '‚ùå'}`;

    return { meets, reason };
  } catch (error) {
    return { meets: false, reason: `–£—Å–ª–æ–≤–∏–µ ${conditionIndex + 1}: ${error.message}` };
  }
}
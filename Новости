/* =========================================================
   –ù–û–í–û–°–¢–ò (RICHTEXT) + –ì–†–£–ü–ü–ò–†–û–í–ö–ê –ü–û CATEGORY ‚Üí SUB
   Google Apps Script (V8)
   ========================================================= */

/* =======================
   –ù–ê–°–¢–†–û–ô–ö–ò –ù–û–í–û–°–¢–ï–ô
   ======================= */

const NEWS_CELL_LIMIT = 45000;

const CATEGORY_ICONS = {
  "–°—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ": "\nüèóÔ∏è",
  "–≠–∫–æ–Ω–æ–º–∏–∫–∞": "\nüí∞",
  "–í–æ–π–Ω–∞": "\n‚öîÔ∏è",
  "–ü–æ–ª–∏—Ç–∏–∫–∞": "\nüèõÔ∏è",
  "–ù–∞—Å–µ–ª–µ–Ω–∏–µ": "\nüë•",
  "–¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏": "\nüî¨",
  "–û–±—â–µ–µ": "\n‚ÑπÔ∏è"
};

/* =======================
   –ù–û–í–û–°–¢–ò: API
   ======================= */

function ensureNews(data) {
  if (!data || typeof data !== "object") throw new Error("data is required");
  if (!Array.isArray(data.–ù–æ–≤–æ—Å—Ç–∏)) data.–ù–æ–≤–æ—Å—Ç–∏ = [];
}

function initNotifications(data) {
  ensureNews(data);
  data.–ù–æ–≤–æ—Å—Ç–∏ = [];
}

function pushNotice(data, n) {
  ensureNews(data);
  data.–ù–æ–≤–æ—Å—Ç–∏.push(n);
}

/* =======================
   –ù–û–í–û–°–¢–ò: –ù–û–†–ú–ê–õ–ò–ó–ê–¶–ò–Ø/–î–ï–î–£–ü/–°–û–†–¢
   ======================= */

function normalizeNotification(n) {
  if (typeof n === "string") {
    return {
      category: "–û–±—â–µ–µ",
      sub: "",
      priority: 100,
      parts: [{ text: n }]
    };
  }

  return {
    category: n.category || "–û–±—â–µ–µ",
    sub: n.sub || "",
    priority: (n.priority ?? 100),
    parts: Array.isArray(n.parts) ? n.parts : [{ text: (n.text || "") }]
  };
}

function notificationKey(n) {
  return JSON.stringify({
    category: n.category,
    sub: n.sub,
    parts: n.parts.map(p => ({
      text: p.text || "",
      bold: !!p.bold,
      italic: !!p.italic,
      color: p.color || ""
    }))
  });
}

function collapseNotifications(list) {
  const map = new Map();

  list.forEach(n => {
    const key = notificationKey(n);
    if (!map.has(key)) {
      map.set(key, { ...n, count: 1 });
    } else {
      const stored = map.get(key);
      stored.count++;
      stored.priority = Math.min(stored.priority, n.priority);
    }
  });

  return Array.from(map.values());
}

function sortCategory(list) {
  return list.sort((a, b) =>
    a.priority - b.priority ||
    (b.count || 1) - (a.count || 1)
  );
}

function groupByCategoryAndSub(list) {
  const groups = {};
  list.forEach(n => {
    const cat = n.category || "–û–±—â–µ–µ";
    const sub = n.sub || "";
    if (!groups[cat]) groups[cat] = {};
    if (!groups[cat][sub]) groups[cat][sub] = [];
    groups[cat][sub].push(n);
  });
  return groups;
}

/* =======================
   RICHTEXT BUILDER
   ======================= */

function buildRichText(parts) {
  const builder = SpreadsheetApp.newRichTextValue();
  let text = "";
  const styles = [];

  parts.forEach(p => {
    const start = text.length;
    text += (p.text || "");
    const end = text.length;
    if (start === end) return;

    let style = SpreadsheetApp.newTextStyle();
    if (p.bold) style = style.setBold(true);
    if (p.italic) style = style.setItalic(true);
    if (p.color) style = style.setForegroundColor(p.color);

    styles.push({ start, end, style: style.build() });
  });

  builder.setText(text);
  styles.forEach(s => builder.setTextStyle(s.start, s.end, s.style));
  return builder.build();
}

function cleanIcon(icon) {
  return String(icon || "‚úé").replace(/\n/g, "");
}

function renderNotificationParts(n) {
  const icon = cleanIcon(CATEGORY_ICONS[n.category]) || "üìå";
  const mult = (n.count || 1) > 1 ? `x${n.count} ` : "";

  return [
    { text: `${mult}${icon} `, bold: true },
    ...n.parts,
    { text: "\n" }
  ];
}

function flushNotifications(data) {
  if (!Array.isArray(data.–ù–æ–≤–æ—Å—Ç–∏)) return;

  const normalized = data.–ù–æ–≤–æ—Å—Ç–∏.map(normalizeNotification);
  const collapsed = collapseNotifications(normalized);
  const grouped = groupByCategoryAndSub(collapsed);

  const cells = [];
  let currentText = "";
  let currentParts = [];

  Object.keys(grouped).sort().forEach(category => {
    const icon = cleanIcon(CATEGORY_ICONS[category]) || "‚úé";

    // –ó–∞–≥–æ–ª–æ–≤–æ–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    const catHeader = `\n${icon} ${category}\n`;
    if (currentText.length + catHeader.length > NEWS_CELL_LIMIT) {
      cells.push(buildRichText(currentParts));
      currentText = "";
      currentParts = [];
    }
    currentText += catHeader;
    currentParts.push({ text: catHeader, bold: true });

    const subsObj = grouped[category];
    const subs = Object.keys(subsObj).sort((a, b) => {
      if (!a && b) return -1;
      if (a && !b) return 1;
      return a.localeCompare(b);
    });

    subs.forEach(sub => {
      // –ü–æ–¥–∑–∞–≥–æ–ª–æ–≤–æ–∫ sub
      if (sub && sub.trim()) {
        const subHeader = `\n‚å¨ ${sub}\n`;
        if (currentText.length + subHeader.length > NEWS_CELL_LIMIT) {
          cells.push(buildRichText(currentParts));
          currentText = "";
          currentParts = [];
        }
        currentText += subHeader;
        currentParts.push({ text: subHeader, bold: true, italic: true });
      }

      // –ó–∞–ø–∏—Å–∏
      sortCategory(subsObj[sub]).forEach(n => {
        const parts = renderNotificationParts(n);
        const text = parts.map(p => p.text || "").join("");

        if (currentText.length + text.length > NEWS_CELL_LIMIT) {
          cells.push(buildRichText(currentParts));
          currentText = text;
          currentParts = parts.slice();
        } else {
          currentText += text;
          currentParts.push(...parts);
        }
      });
    });
  });

  if (currentText.trim()) cells.push(buildRichText(currentParts));
  data.–ù–æ–≤–æ—Å—Ç–∏ = cells;
}